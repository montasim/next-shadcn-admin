generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model AuthSession {
  id        String   @id
  email     String
  intent    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email, intent])
  @@map("auth_sessions")
}

model Invite {
  id        String    @id @default(uuid())
  email     String    @unique
  token     String    @unique
  invitedBy String
  desc      String?
  expiresAt DateTime
  used      Boolean   @default(false)
  createdAt DateTime  @default(now())
  usedAt    DateTime?
  role      UserRole  @default(ADMIN)

  @@index([email, expiresAt])
  @@index([token])
  @@map("invites")
}

model Author {
  id             String       @id @default(uuid())
  name           String
  description    String?
  image          String?
  directImageUrl String?
  entryDate      DateTime     @default(now())
  entryById   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  entryBy     User         @relation("UserAuthors", fields: [entryById], references: [id])
  books       BookAuthor[]

  // Analytics
  views         AuthorView[]

  @@map("authors")
}

model Publication {
  id             String            @id @default(uuid())
  name           String
  description    String?
  image          String?
  directImageUrl String?
  entryDate      DateTime          @default(now())
  entryById   String
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  books       BookPublication[]
  entryBy     User              @relation("UserPublications", fields: [entryById], references: [id])

  // Analytics
  views         PublicationView[]

  @@map("publications")
}

model Category {
  id             String         @id @default(uuid())
  name           String         @unique
  description    String?
  image          String?
  directImageUrl String?
  entryDate      DateTime       @default(now())
  entryById   String
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  books       BookCategory[]
  entryBy     User           @relation("UserCategories", fields: [entryById], references: [id])

  // Analytics
  views         CategoryView[]

  // Mood mappings
  moodMappings MoodCategoryMapping[]

  @@map("categories")
}

model Series {
  id             String       @id @default(uuid())
  name           String       @unique
  description    String?
  image          String?
  directImageUrl String?
  entryDate      DateTime     @default(now())
  entryById      String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  books          BookSeries[]
  entryBy        User         @relation("UserSeries", fields: [entryById], references: [id])

  // Analytics
  views          SeriesView[]

  @@map("series")
}

// Mood configuration for mood-based book recommendations
model Mood {
  id           String               @id @default(uuid())
  identifier   String               @unique  // e.g., 'happy', 'adventurous'
  name         String               // Display name e.g., 'Happy'
  emoji        String               // e.g., 'ðŸ˜Š'
  description  String               // e.g., 'Feel-good stories...'
  color        String               // CSS classes for styling
  isActive     Boolean              @default(true)
  order        Int                  @default(0) // Display order
  entryById    String
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  entryBy      User                 @relation("UserMoods", fields: [entryById], references: [id])
  mappings     MoodCategoryMapping[]

  @@map("moods")
}

// Many-to-many mapping between moods and categories
model MoodCategoryMapping {
  id         String   @id @default(uuid())
  moodId     String
  categoryId String
  createdAt  DateTime @default(now())
  mood       Mood     @relation(fields: [moodId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([moodId, categoryId])
  @@index([moodId])
  @@index([categoryId])
  @@map("mood_category_mappings")
}

model Book {
  id                  String            @id @default(uuid())
  name                String
  image               String?
  directImageUrl      String?
  type                BookType
  buyingPrice         Float?
  sellingPrice        Float?
  numberOfCopies      Int?
  purchaseDate        DateTime?
  entryDate           DateTime          @default(now())
  entryById           String
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  bindingType         BindingType?
  fileUrl             String?
  directFileUrl       String?
  isPublic            Boolean           @default(false)
  pageNumber          Int?
  requiresPremium     Boolean           @default(false)
  summary             String?
  authors             BookAuthor[]
  categories          BookCategory[]
  publications        BookPublication[]
  series              BookSeries[]
  entryBy             User              @relation("UserBooks", fields: [entryById], references: [id])
  bookshelves         BookshelfItem[]
  progressHistory     ProgressHistory[]
  readingProgress     ReadingProgress[]

  // Content cache fields
  extractedContent    String?           // Full extracted text content
  contentExtractedAt  DateTime?         // When content was extracted
  contentHash         String?           // MD5 hash to detect changes
  contentVersion      Int               @default(0) // Increment on changes
  extractionStatus    String?           // 'pending', 'completed', 'failed'
  contentPageCount    Int?              // Number of pages
  contentWordCount    Int?              // Word count
  contentSize         Int?              // Size in bytes

  // AI-generated summary
  aiSummary                    String?           // ~200 word AI summary
  aiSummaryGeneratedAt         DateTime?         // When summary was generated
  aiSummaryStatus              String?           // 'pending', 'completed', 'failed'

  // Question generation tracking
  questionsGeneratedAt         DateTime?         // When questions were generated
  questionsStatus              String?           // 'pending', 'completed', 'failed'

  // Questions relationship
  questions                    BookQuestion[]

  // Analytics and chat history
  views                        BookView[]
  chatMessages                 BookChatMessage[]

  // Marketplace relations
  sellPosts                    BookSellPost[]            @relation("BookSellPosts")

  // Reviews relationship
  reviews                      BookReview[]

  @@map("books")
}

model BookAuthor {
  id        String   @id @default(uuid())
  bookId    String
  authorId  String
  createdAt DateTime @default(now())
  author    Author   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([bookId, authorId])
  @@map("book_authors")
}

model BookPublication {
  id            String      @id @default(uuid())
  bookId        String
  publicationId String
  createdAt     DateTime    @default(now())
  book          Book        @relation(fields: [bookId], references: [id], onDelete: Cascade)
  publication   Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)

  @@unique([bookId, publicationId])
  @@map("book_publications")
}

model BookCategory {
  id         String   @id @default(uuid())
  bookId     String
  categoryId String
  createdAt  DateTime @default(now())
  book       Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([bookId, categoryId])
  @@map("book_categories")
}

model BookSeries {
  id        String   @id @default(uuid())
  bookId    String
  seriesId  String
  order     Float    // Position in series (can have decimals like 1.5, 2.5 for prequels/interquels)
  createdAt DateTime @default(now())

  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  series    Series   @relation(fields: [seriesId], references: [id], onDelete: Cascade)

  @@unique([bookId, seriesId])
  @@index([seriesId, order])
  @@map("book_series")
}

model BookQuestion {
  id              String   @id @default(uuid())
  bookId          String
  question        String   // The question text
  answer          String   // The answer text
  order           Int      // Display order (1-20)
  isAIGenerated   Boolean  @default(true) // Track if AI-generated or manual
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  book            Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([bookId, order])
  @@map("book_questions")
}

model BookReview {
  id              String   @id @default(uuid())
  bookId          String
  userId          String
  rating          Int      // 1-5 stars
  comment         String?  @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  book            Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user            User     @relation("UserBookReviews", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([bookId, userId]) // One review per user per book
  @@index([bookId])
  @@index([userId])
  @@map("book_reviews")
}

model BookView {
  id          String    @id @default(uuid())
  bookId      String
  userId      String?   // Nullable for anonymous visits
  sessionId   String?   // For anonymous tracking
  visitedAt   DateTime  @default(now())
  ip          String?   // Optional IP tracking
  userAgent   String?   // Browser info
  referrer    String?   // Where they came from

  book        Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([bookId, visitedAt])
  @@index([userId, visitedAt])
  @@map("book_views")
}

model BookChatMessage {
  id            String      @id @default(uuid())
  bookId        String
  userId        String
  sessionId     String      // To group messages into conversations
  role          String      // 'user' or 'assistant'
  content       String      @db.Text
  createdAt     DateTime    @default(now())
  messageIndex  Int         // Order within session

  book          Book        @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([bookId, userId, sessionId])
  @@index([bookId, createdAt])
  @@map("book_chat_messages")
}

model AuthorView {
  id          String    @id @default(uuid())
  authorId    String
  userId      String?   // Nullable for anonymous visits
  sessionId   String?   // For anonymous tracking
  visitedAt   DateTime  @default(now())
  ip          String?   // Optional IP tracking
  userAgent   String?   // Browser info
  referrer    String?   // Where they came from

  author      Author    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([authorId, visitedAt])
  @@index([userId, visitedAt])
  @@map("author_views")
}

model PublicationView {
  id          String    @id @default(uuid())
  publicationId String
  userId      String?   // Nullable for anonymous visits
  sessionId   String?   // For anonymous tracking
  visitedAt   DateTime  @default(now())
  ip          String?   // Optional IP tracking
  userAgent   String?   // Browser info
  referrer    String?   // Where they came from

  publication Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([publicationId, visitedAt])
  @@index([userId, visitedAt])
  @@map("publication_views")
}

model CategoryView {
  id          String    @id @default(uuid())
  categoryId  String
  userId      String?   // Nullable for anonymous visits
  sessionId   String?   // For anonymous tracking
  visitedAt   DateTime  @default(now())
  ip          String?   // Optional IP tracking
  userAgent   String?   // Browser info
  referrer    String?   // Where they came from

  category    Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([categoryId, visitedAt])
  @@index([userId, visitedAt])
  @@map("category_views")
}

model SeriesView {
  id          String    @id @default(uuid())
  seriesId    String
  userId      String?   // Nullable for anonymous visits
  sessionId   String?   // For anonymous tracking
  visitedAt   DateTime  @default(now())
  ip          String?   // Optional IP tracking
  userAgent   String?   // Browser info
  referrer    String?   // Where they came from

  series      Series    @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([seriesId, visitedAt])
  @@index([userId, visitedAt])
  @@map("series_views")
}

model BookRequest {
  id            String        @id @default(uuid())
  bookName      String
  authorName    String
  type          BookType
  edition       String?
  publisher     String?
  isbn          String?
  description   String?
  status        RequestStatus @default(PENDING)
  requestedById String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  cancelReason  String?
  cancelledById String?
  cancelledBy   User?         @relation("UserCancelledRequests", fields: [cancelledById], references: [id])
  requestedBy   User          @relation("UserBookRequests", fields: [requestedById], references: [id])

  @@index([requestedById, status])
  @@map("book_requests")
}

model User {
  id                  String            @id @default(uuid())
  email               String            @unique
  passwordHash        String
  role                UserRole          @default(USER)
  name                String            @default("")
  firstName           String            @default("")
  lastName            String?
  username            String?           @unique
  phoneNumber         String?           @unique
  avatar              String?
  directAvatarUrl     String?
  bio                 String?
  dob                 DateTime?
  theme               String?           @default("light")
  font                String?           @default("inter")
  language            String?
  notificationType    String?           @default("all")
  displayItems        Json?             @default("[\"recents\", \"home\", \"applications\", \"desktop\", \"downloads\", \"documents\"]")
  urls                Json?             @default("[]")
  showMoodRecommendations Boolean        @default(true)
  communicationEmails Boolean?          @default(false)
  marketingEmails     Boolean?          @default(false)
  securityEmails      Boolean?          @default(true)
  socialEmails        Boolean?          @default(false)
  mobileNotifications Boolean?          @default(false)
  isPremium           Boolean           @default(false)
  isActive            Boolean           @default(true)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  authoredBooks       Author[]          @relation("UserAuthors")
  cancelledRequests   BookRequest[]     @relation("UserCancelledRequests")
  bookRequests        BookRequest[]     @relation("UserBookRequests")
  books               Book[]            @relation("UserBooks")
  bookshelves         Bookshelf[]
  categorizedBooks    Category[]        @relation("UserCategories")
  series              Series[]          @relation("UserSeries")
  progressHistory     ProgressHistory[]
  publishedBooks      Publication[]     @relation("UserPublications")
  readingProgress     ReadingProgress[]
  achievements        UserAchievement[]  @relation("UserAchievements")
  subscription        Subscription?
  sessions            UserSession[]
  quizAttempts       QuizAttempt[]
  quizStreak          QuizStreak?

  // Mood management
  moods               Mood[]             @relation("UserMoods")

  // Notices management
  notices             Notice[]           @relation("UserNotices")

  // Analytics and chat history
  bookViews           BookView[]
  chatMessages        BookChatMessage[]
  authorViews         AuthorView[]
  publicationViews    PublicationView[]
  categoryViews       CategoryView[]
  seriesViews         SeriesView[]
  bookReviews         BookReview[]        @relation("UserBookReviews")

  // Marketplace relations
  sellPosts              BookSellPost[]              @relation("UserSellPosts")
  buyerOffers            BookOffer[]                 @relation("UserBuyerOffers")
  sellerConversations    Conversation[]              @relation("UserSellerConversations")
  buyerConversations     Conversation[]              @relation("UserBuyerConversations")
  sentMessages           Message[]                   @relation("UserSentMessages")
  givenReviews           SellerReview[]              @relation("UserGivenReviews")
  sellPostViews          SellPostView[]              @relation("UserSellPostViews")

  // Notifications
  notifications          Notification[]

  // WebSocket features
  onlineStatus           OnlineStatus?              @relation("UserOnlineStatus")
  typingIndicators       TypingIndicator[]          @relation("UserTypingIndicators")

  // Activity tracking
  activities             ActivityLog[]              @relation("UserActivities")

  // Support tickets
  tickets                SupportTicket[]            @relation("UserTickets")
  assignedTickets        SupportTicket[]            @relation("AssignedTickets")
  ticketResponses        TicketResponse[]           @relation("TicketResponses")

  // Legal content management
  updatedLegalContent    LegalContent[]            @relation("UserLegalContent")

  // Campaign management
  campaigns              Campaign[]                @relation("UserCampaigns")

  @@map("users")
}

// ============================================================================
// WEBSOCKET MODELS
// ============================================================================

model OnlineStatus {
  id          String     @id @default(uuid())
  userId      String     @unique
  socketId    String?
  status      UserStatus @default(OFFLINE)
  lastSeenAt  DateTime   @default(now())
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  user        User       @relation("UserOnlineStatus", fields: [userId], references: [id], onDelete: Cascade)

  @@index([status, lastSeenAt])
  @@map("online_status")
}

model TypingIndicator {
  id               String       @id @default(uuid())
  conversationId   String
  userId           String
  isTyping         Boolean      @default(true)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  conversation     Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user             User         @relation("UserTypingIndicators", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@map("typing_indicators")
}

model UserOtp {
  id        String   @id @default(uuid())
  email     String
  codeHash  String
  intent    String
  used      Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email, intent])
  @@map("user_otps")
}

model UserSession {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@map("user_sessions")
}

model Subscription {
  id        String           @id @default(uuid())
  userId    String           @unique
  plan      SubscriptionPlan @default(FREE)
  startDate DateTime         @default(now())
  endDate   DateTime?
  isActive  Boolean          @default(true)
  paymentId String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model ReadingProgress {
  id            String   @id @default(uuid())
  userId        String
  bookId        String
  currentPage   Int?
  currentEpocha Float?
  progress      Float    @default(0)
  isCompleted   Boolean  @default(false)
  lastReadAt    DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  book          Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
  @@map("reading_progress")
}

model ProgressHistory {
  id            String   @id @default(uuid())
  userId        String
  bookId        String
  currentPage   Int?
  currentEpocha Float?
  progress      Float    @default(0)
  pagesRead     Int      @default(0)
  timeSpent     Int      @default(0)
  sessionDate   DateTime @default(now())
  createdAt     DateTime @default(now())
  book          Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, bookId, sessionDate])
  @@map("progress_history")
}

model Bookshelf {
  id             String          @id @default(uuid())
  userId         String
  name           String
  description    String?
  isPublic       Boolean         @default(false)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  image          String?
  directImageUrl String?
  books          BookshelfItem[]
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("bookshelves")
}

model BookshelfItem {
  id          String    @id @default(uuid())
  bookshelfId String
  bookId      String
  addedAt     DateTime  @default(now())
  book        Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookshelf   Bookshelf @relation(fields: [bookshelfId], references: [id], onDelete: Cascade)

  @@unique([bookshelfId, bookId])
  @@map("bookshelf_items")
}

model QuizAttempt {
  id                String   @id @default(uuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Quiz metadata
  category          String
  difficulty        String   // easy, medium, hard
  questionCount     Int

  // Results
  score             Int      // Number of correct answers
  totalQuestions    Int
  accuracy          Float    // Percentage (0-100)
  timeTaken         Int?     // Seconds

  // Streaks achieved in this quiz
  quizStreak        Int      // Max consecutive correct answers
  dailyStreakAtTime Int      // Daily streak value when quiz was completed

  // Combined score for leaderboard
  combinedScore     Int

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([combinedScore(sort: Desc)])
  @@index([createdAt])
  @@map("quiz_attempts")
}

model QuizStreak {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Daily streak (consecutive days with at least one win)
  currentDailyStreak Int     @default(0)
  bestDailyStreak    Int     @default(0)
  lastQuizDate       DateTime?

  // Best quiz streak (consecutive correct answers in single quiz)
  bestQuizStreak     Int     @default(0)

  // Stats
  totalQuizzes       Int     @default(0)
  totalWins          Int     @default(0) // Score >= 50%
  totalCorrect       Int     @default(0)
  totalQuestions     Int     @default(0)

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([userId])
  @@map("quiz_streaks")
}

// ============================================================================
// CAMPAIGN MANAGEMENT
// ============================================================================

enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  FAILED
  CANCELLED
}

enum CampaignType {
  ONE_TIME       // Send once immediately or scheduled
  RECURRING      // Recurring campaign (cron-based)
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  CUSTOM
}

model Campaign {
  id                String                @id @default(uuid())
  name              String
  subject           String
  previewText       String?
  htmlContent       String                @db.Text
  markdownContent   String                @db.Text  // Store original markdown

  // Campaign type
  type              CampaignType          @default(ONE_TIME)

  // Recipients
  targetAllUsers    Boolean               @default(true)
  targetRole        UserRole?
  recipientCount    Int                   @default(0)

  // Status tracking
  status            CampaignStatus        @default(DRAFT)
  scheduledAt       DateTime?
  sentAt            DateTime?

  // Recurring settings (for RECURRING type)
  isRecurring       Boolean               @default(false)
  recurrenceFrequency RecurrenceFrequency?
  recurrenceCron    String?               // Custom cron expression
  recurrenceEndDate  DateTime?            // When to stop recurring
  nextRunAt         DateTime?             // Next scheduled run for recurring

  // Delivery stats
  sentCount         Int                   @default(0)
  deliveredCount    Int                   @default(0)
  failedCount       Int                   @default(0)
  openedCount       Int                   @default(0)
  clickedCount      Int                   @default(0)

  // Unsubscribe tracking
  unsubscribeCount  Int                   @default(0)

  // Metadata
  entryById         String
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt

  entryBy           User                  @relation("UserCampaigns", fields: [entryById], references: [id])
  recipients        CampaignRecipient[]

  @@index([status, createdAt(sort: Desc)])
  @@index([entryById])
  @@index([nextRunAt])
  @@map("campaigns")
}

model CampaignRecipient {
  id                String         @id @default(uuid())
  campaignId        String
  userId            String
  userEmail         String         // Denormalized for filtering

  // Delivery status
  status            CampaignStatus @default(DRAFT)
  sentAt            DateTime?
  deliveredAt       DateTime?
  openedAt          DateTime?
  clickedAt         DateTime?
  unsubscribedAt    DateTime?      // When user unsubscribed from this campaign
  failedReason      String?

  // Engagement tracking (for links clicked)
  clickedLinks      Json?          // Track which links were clicked

  // Retry tracking
  retryCount        Int            @default(0)
  lastRetryAt       DateTime?

  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  campaign          Campaign       @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@unique([campaignId, userId])
  @@index([campaignId, status])
  @@index([userId, createdAt(sort: Desc)])
  @@map("campaign_recipients")
}

enum BookType {
  HARD_COPY
  EBOOK
  AUDIO
}

enum BindingType {
  HARDCOVER
  PAPERBACK
}

enum SubscriptionPlan {
  FREE
  PREMIUM
  PREMIUM_PLUS
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum RequestStatus {
  PENDING
  IN_PROGRESS
  APPROVED
  REJECTED
}

// ============================================================================
// MARKETPLACE ENUMS
// ============================================================================

enum BookCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  POOR
}

enum SellPostStatus {
  AVAILABLE
  PENDING
  SOLD
  EXPIRED
  HIDDEN
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  COUNTERED
  WITHDRAWN
  EXPIRED
}

enum ConversationStatus {
  ACTIVE
  ARCHIVED
  COMPLETED
  BLOCKED
}

// ============================================================================
// MARKETPLACE MODELS
// ============================================================================

model BookSellPost {
  id                String             @id @default(uuid())
  title             String
  description       String?            @db.Text
  price             Float
  negotiable        Boolean            @default(true)
  condition         BookCondition
  images            String[]           // Array of image URLs
  directImageUrls   Json?              // Store direct URLs for each image

  // Book reference (links to existing Book model if applicable)
  bookId            String?
  book              Book?              @relation("BookSellPosts", fields: [bookId], references: [id], onDelete: SetNull)

  // Seller info
  sellerId          String
  seller            User               @relation("UserSellPosts", fields: [sellerId], references: [id], onDelete: Cascade)

  // Location for meetup
  location          String?
  city              String?

  // Status
  status            SellPostStatus     @default(AVAILABLE)
  soldAt            DateTime?

  // Timestamps
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  expiresAt         DateTime?          // Optional expiration for listings

  // Relations
  offers            BookOffer[]
  conversations     Conversation[]
  reviews           SellerReview[]

  // Analytics
  views             SellPostView[]

  @@index([sellerId, status])
  @@index([status, createdAt])
  @@index([bookId])
  @@map("book_sell_posts")
}

model BookOffer {
  id                String             @id @default(uuid())
  sellPostId        String
  sellPost          BookSellPost       @relation(fields: [sellPostId], references: [id], onDelete: Cascade)

  buyerId           String
  buyer             User               @relation("UserBuyerOffers", fields: [buyerId], references: [id], onDelete: Cascade)

  offeredPrice      Float
  message           String?            @db.Text

  status            OfferStatus        @default(PENDING)
  respondedAt       DateTime?
  responseMessage   String?            @db.Text

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([sellPostId, status])
  @@index([buyerId, status])
  @@map("book_offers")
}

model Conversation {
  id                String             @id @default(uuid())
  sellPostId        String
  sellPost          BookSellPost       @relation(fields: [sellPostId], references: [id], onDelete: Cascade)

  // Participants
  sellerId          String
  buyerId           String
  seller            User               @relation("UserSellerConversations", fields: [sellerId], references: [id], onDelete: Cascade)
  buyer             User               @relation("UserBuyerConversations", fields: [buyerId], references: [id], onDelete: Cascade)

  // Status
  status            ConversationStatus @default(ACTIVE)
  completedAt       DateTime?

  // Transaction completion (for reviews)
  transactionCompleted Boolean        @default(false)

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  messages          Message[]
  review            SellerReview?
  typingIndicators  TypingIndicator[]

  @@unique([sellPostId, buyerId])
  @@index([sellerId, status])
  @@index([buyerId, status])
  @@map("conversations")
}

model Message {
  id                String             @id @default(uuid())
  conversationId    String
  conversation      Conversation       @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId          String
  sender            User               @relation("UserSentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  content           String             @db.Text

  // Read status
  readAt            DateTime?

  createdAt         DateTime           @default(now())

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("messages")
}

model SellerReview {
  id                String             @id @default(uuid())
  conversationId    String             @unique
  conversation      Conversation       @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  sellPostId        String
  sellPost          BookSellPost       @relation(fields: [sellPostId], references: [id], onDelete: Cascade)

  reviewerId        String             // The buyer who left the review
  reviewer          User               @relation("UserGivenReviews", fields: [reviewerId], references: [id], onDelete: Cascade)

  sellerId          String             // The seller being reviewed (denormalized for queries)

  rating            Int                // 1-5 stars

  // Review categories
  communicationRating     Int          @default(0)
  descriptionAccuracyRating Int       @default(0)
  meetupRating            Int          @default(0)

  comment           String?            @db.Text

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([sellerId])
  @@index([reviewerId])
  @@map("seller_reviews")
}

model SellPostView {
  id                String             @id @default(uuid())
  sellPostId        String
  sellPost          BookSellPost       @relation(fields: [sellPostId], references: [id], onDelete: Cascade)

  userId            String?            // Nullable for anonymous visits
  sessionId         String?            // For anonymous tracking

  visitedAt         DateTime           @default(now())
  ip                String?
  userAgent         String?
  referrer          String?

  user              User?              @relation("UserSellPostViews", fields: [userId], references: [id], onDelete: SetNull)

  @@index([sellPostId, visitedAt])
  @@index([userId, visitedAt])
  @@map("sell_post_views")
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

enum NotificationType {
  NEW_MESSAGE
  NEW_OFFER
  OFFER_ACCEPTED
  OFFER_REJECTED
  OFFER_COUNTERED
  TRANSACTION_COMPLETE
  NEW_REVIEW
  POST_APPROVED
  POST_REJECTED
  MARKETPLACE_UPDATE
}

// WebSocket features
enum UserStatus {
  ONLINE
  AWAY
  OFFLINE
}

model Notification {
  id          String             @id @default(uuid())
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  type        NotificationType
  title       String
  message     String             @db.Text

  // Optional links to related entities
  linkUrl     String?

  // Read status
  isRead      Boolean            @default(false)
  readAt      DateTime?

  createdAt   DateTime           @default(now())

  @@index([userId, isRead, createdAt])
  @@index([userId, createdAt])
  @@map("notifications")
}

// ============================================================================
// SYSTEM SETTINGS
// ============================================================================

// System-wide settings
model SystemSettings {
  id                        String   @id @default(uuid())
  underConstruction         Boolean  @default(false)
  underConstructionMessage  String?  @default("Site is under construction. Some features may not work as expected.")
  maintenanceMode           Boolean  @default(false)
  maintenanceMessage        String?
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  @@map("system_settings")
}

// Notices/Announcements for users
model Notice {
  id           String    @id @default(uuid())
  title        String
  content      String    @db.Text
  isActive     Boolean   @default(true)
  validFrom    DateTime? // Optional start date
  validTo      DateTime? // Optional end date
  order        Int       @default(0) // Display order
  entryById    String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  entryBy      User      @relation("UserNotices", fields: [entryById], references: [id])

  @@index([isActive, validFrom, validTo])
  @@map("notices")
}

// ============================================================================
// ACTIVITY & AUDIT LOGGING
// ============================================================================

enum ActivityAction {
  // CRUD
  CREATE
  UPDATE
  DELETE
  VIEW

  // Auth
  LOGIN
  LOGOUT
  LOGIN_FAILED
  PASSWORD_CHANGED
  ROLE_CHANGED

  // Books
  BOOK_CREATED
  BOOK_UPDATED
  BOOK_DELETED
  BOOK_VIEWED
  AUTHOR_CREATED
  AUTHOR_UPDATED
  AUTHOR_DELETED
  CATEGORY_CREATED
  CATEGORY_UPDATED
  CATEGORY_DELETED
  PUBLICATION_CREATED
  PUBLICATION_UPDATED
  PUBLICATION_DELETED
  SERIES_CREATED
  SERIES_UPDATED
  SERIES_DELETED

  // Marketplace
  SELL_POST_CREATED
  SELL_POST_UPDATED
  SELL_POST_DELETED
  OFFER_CREATED
  OFFER_ACCEPTED
  OFFER_REJECTED
  MESSAGE_SENT
  REVIEW_POSTED

  // User
  PROFILE_UPDATED
  BOOKSHELF_CREATED
  BOOK_ADDED_TO_BOOKSHELF
  READING_PROGRESS_UPDATED
  QUIZ_ATTEMPTED

  // System
  SYSTEM_SETTINGS_UPDATED
  NOTICE_CREATED
  NOTICE_UPDATED
  NOTICE_DELETED
  USER_BANNED
  USER_PROMOTED

  // Campaigns
  CAMPAIGN_CREATED
  CAMPAIGN_UPDATED
  CAMPAIGN_DELETED
  CAMPAIGN_SENT
  CAMPAIGN_CANCELLED
}

enum ActivityResourceType {
  BOOK
  AUTHOR
  PUBLICATION
  CATEGORY
  SERIES
  USER
  BOOKSHELF
  READING_PROGRESS
  QUIZ_ATTEMPT
  SELL_POST
  OFFER
  MESSAGE
  CONVERSATION
  REVIEW
  NOTICE
  SYSTEM_SETTINGS
  ACHIEVEMENT_UNLOCKED
  CAMPAIGN
}

// ============================================================================
// ACHIEVEMENTS SYSTEM
// ============================================================================

model Achievement {
  id                String              @id @default(uuid())
  code              String              @unique  // e.g., 'FIRST_BOOK', 'READER_10'
  name              String              // Display name
  description       String              @db.Text
  icon              String?             // Emoji or icon name
  category          AchievementCategory
  tier              AchievementTier     @default(BRONZE)
  xp                Int                 @default(0)  // Experience points rewarded

  // Requirements (stored as JSON for flexibility)
  requirements      Json                // { type: 'BOOKS_READ', count: 10, etc. }

  // Stats
  unlockCount       Int                 @default(0)  // How many users unlocked this
  isVisible         Boolean             @default(true)

  // Metadata
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  entryById         String

  userAchievements  UserAchievement[]

  @@index([category, tier])
  @@index([code])
  @@map("achievements")
}

model UserAchievement {
  id              String              @id @default(uuid())
  userId          String
  achievementId   String
  unlockedAt      DateTime            @default(now())

  // Progress tracking (for incremental achievements)
  progress        Int                 @default(0)
  maxProgress     Int                 @default(1)

  user            User                @relation("UserAchievements", fields: [userId], references: [id], onDelete: Cascade)
  achievement     Achievement         @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId, unlockedAt(sort: Desc)])
  @@index([achievementId])
  @@map("user_achievements")
}

enum AchievementCategory {
  READING           // Books completed, pages read
  COLLECTION        // Books added, authors, categories
  QUIZ              // Quiz scores, streaks, wins
  MARKETPLACE       // Sell posts, offers, reviews
  SOCIAL            // Reviews, ratings, conversations
  ENGAGEMENT        // Logins, consistency, streaks
  SPECIAL           // Limited time, unique achievements
}

enum AchievementTier {
  BRONZE            // Entry level
  SILVER            // Intermediate
  GOLD              // Advanced
  PLATINUM          // Expert
  DIAMOND           // Master
  LEGENDARY         // Ultra rare
}

model ActivityLog {
  id                String              @id @default(uuid())

  // Who
  userId            String?
  user              User?               @relation("UserActivities", fields: [userId], references: [id], onDelete: SetNull)
  userRole          UserRole?

  // What
  action            ActivityAction
  resourceType      ActivityResourceType
  resourceId        String?
  resourceName      String?             @db.Text

  // Details
  description       String?             @db.Text
  metadata          Json?
  ipAddress         String?
  userAgent         String?             @db.Text

  // Context
  endpoint          String?

  // Result
  success           Boolean             @default(true)
  errorMessage      String?             @db.Text

  // Performance
  duration          Int?                // ms

  // Timestamp
  createdAt         DateTime            @default(now())

  @@index([userId, createdAt(sort: Desc)])
  @@index([resourceType, resourceId, createdAt])
  @@index([action, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("activity_logs")
}

// ============================================================================
// SUPPORT TICKETS SYSTEM
// ============================================================================

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_FOR_USER
  RESOLVED
  CLOSED
}

model SupportTicket {
  id                String           @id @default(uuid())

  // User info
  userId            String
  user              User             @relation("UserTickets", fields: [userId], references: [id], onDelete: Cascade)
  userEmail          String
  userName           String

  // Ticket details
  subject           String
  description       String           @db.Text
  category          String           // e.g., 'technical', 'billing', 'feature', 'bug'
  priority          TicketPriority   @default(MEDIUM)
  status            TicketStatus     @default(OPEN)

  // Admin assignment
  assignedToId      String?
  assignedTo        User?            @relation("AssignedTickets", fields: [assignedToId], references: [id], onDelete: SetNull)

  // Resolution
  resolution        String?          @db.Text
  resolvedAt        DateTime?

  // Timestamps
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  closedAt          DateTime?

  // Relations
  responses         TicketResponse[]

  @@index([userId, status, createdAt(sort: Desc)])
  @@index([status, priority, createdAt(sort: Desc)])
  @@index([assignedToId, status])
  @@map("support_tickets")
}

model TicketResponse {
  id                String           @id @default(uuid())

  ticketId          String
  ticket            SupportTicket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  // Response info
  senderId          String
  sender            User             @relation("TicketResponses", fields: [senderId], references: [id], onDelete: Cascade)
  senderRole        UserRole         @default(USER)
  isFromAdmin       Boolean          @default(false)

  message           String           @db.Text

  // Attachments (optional)
  attachments       Json?            // Array of file URLs

  createdAt         DateTime         @default(now())

  @@index([ticketId, createdAt(sort: Asc)])
  @@map("ticket_responses")
}

// FAQ for help center
model FAQ {
  id                String           @id @default(uuid())

  question          String
  answer            String           @db.Text
  category          String           // e.g., 'account', 'reading', 'marketplace', 'technical'
  order             Int              @default(0)

  isActive          Boolean          @default(true)

  // Metadata
  views             Int              @default(0)
  helpfulCount      Int              @default(0)
  notHelpfulCount   Int              @default(0)

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@index([category, order])
  @@index([isActive])
  @@map("faqs")
}

// Legal content pages (Terms, Privacy, etc.)
model LegalContent {
  id                String           @id @default(uuid())
  type              LegalContentType @unique
  title             String
  content           String           @db.Text  // Markdown content
  lastUpdatedById   String
  lastUpdatedBy     User             @relation("UserLegalContent", fields: [lastUpdatedById], references: [id])
  effectiveDate     DateTime         @default(now())
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@index([type])
  @@map("legal_content")
}

enum LegalContentType {
  TERMS_OF_SERVICE
  PRIVACY_POLICY
  COOKIE_POLICY
  DISCLAIMER
}
